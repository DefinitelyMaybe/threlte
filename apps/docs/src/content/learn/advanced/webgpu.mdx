---
category: Advanced
title: WebGPU and TSL
order: 1
---

<Tip type="warning">
  WebGPU support in Three.js is still in an early stage and the implementation may change from
  Three.js version to version. This guide is based on Three.js r169.
</Tip>

## WebGPU

To use three.js's WebGPU renderer, import it and then initialize it within your `<Canvas>`'s `createRenderer` event prop.

<Tip type="note">
  WebGPU is still an experimental browser api and at the time of writing has 73% global
  [support](https://caniuse.com/?search=webgpu). For this reason, three.js's webgpu renderer
  fallbacks to webgl when webgpu is not available.
</Tip>

```svelte title="App.svelte"
<script>
  import Scene from './Scene.svelte'
  import * as THREE from 'three/webgpu'
</script>

<Canvas
  createRenderer={(canvas) => {
    return new THREE.WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
  }}
>
  <Scene />
</Canvas>
```

<Tip type="tip">
  This same approach can be used to swap out the default renderer for any other custom renderer.
</Tip>

<Example path="renderers/WebGPU" />

<small>
  Adapted from [this Three.js
  example](https://threejs.org/examples/?q=webgpu#webgpu_performance_renderbundle).
</small>

### Use consistent imports

Since [Three.js r167](https://github.com/mrdoob/three.js/releases/tag/r167),
Three.js provides a dedicated WebGPU build, available as `three/webgpu`.
Whenever you're targeting WebGPU, you should always import the WebGPU build
instead of the default `three` build:

```ts {1}- {2}+
import * as THREE from 'three'
import * as THREE from 'three/webgpu'
```

### Extend the catalogue

You also should extend the Threlte catalogue with the WebGPU build.

```svelte title="App.svelte" {2}+ {6}+
<script>
  import { extend } from '@threlte/core'
  import Scene from './Scene.svelte'
  import * as THREE from 'three/webgpu'

  extend(THREE)
</script>

<Canvas
  createRenderer={(canvas) => {
    return new THREE.WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
  }}
>
  <Scene />
</Canvas>
```

This gives the `<T>` component the extra class definitions to use things like `MeshPhysicalNodeMaterial` like so:

```svelte
<T.MeshPhysicalNodeMaterial />
```

### Vite

The WebGPURenderer uses top-level async to determine WebGPU compatibility. Vite
will often throw an error when it detects top level await.

To circumvent this issue, the following can be added to your Vite config.

```js
// vite.config.js
optimizeDeps: {
  esbuildOptions: {
    target: 'esnext'
  }
},
build: {
  target: 'esnext'
}
```

Alternatively,
[`vite-plugin-top-level-await`](https://github.com/Menci/vite-plugin-top-level-await)
can be used, although less success has been reported with this method.

## TSL

A question that comes up often in ThreeJS development is "How do I extend ThreeJS's materials?". Most libraries such as [three-custom-shader-material](https://www.npmjs.com/package/three-custom-shader-material) use a find and replace solution. This works well enough but ThreeJS has identified that it's not an ideal solution and recommends using the threejs shading language, otherwise known as [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language). One of the primary benefits for using TSL is that the language is renderer-agnostic. This means TSL will compile to either glsl or wgsl code depending on what renderer is being used.

The example below is an adaptation of [this](https://threejs.org/examples/?q=tsl#webgpu_tsl_angular_slicing) threejs example.

<Example path="shaders/slice/main" />

Node materials give the developer the ability to modify three's builtin materials.
In the example above, two nodes are modified; the `outputNode` and the `shadowNode`.
The `outputNode` is set up in such a way that it discards any fragments that are
outside the permitted `startAngle` and `arcAngle`. If a fragment is not discarded
and it is not front-facing, it is assigned the color in the `color` uniform. The
material needs its `side` set to `Three.DoubleSide` otherwise as these
fragments are facing away from the camera, threejs would cull them out.

Any fragment that is discarded in the shadowNode will not cast shadows.

The nodes can be directly assigned like any other prop on the `<T>` component.

```svelte
<T.MeshPhysicalNodeMaterial
  outputNode={Fn(([arg1, arg2]) => {
    /* ... */
  })(arg1, arg2)}
  shadowNode={Fn(([arg1, arg2]) => {
    /* ... */
  })(arg2, arg2)}
/>
```

Various TSL functions such as `If`, `Fn`, and `vec4` can be imported from `three/webgpu`

If your node depends on uniforms, these can be declared the the `script` tag of the component and updated via `$effect` or a callback.

For example, if your material uses elapsed time in a uniform, you can update the uniform inside a `useTask` callback.

<Example path="shaders/slice/updatingUniforms" />

The material demonstrates two ways to update uniforms. The `uTime` uniform is updated in a `useTask` callback. `uIntensity` is modified in a `$effect`. Either way the uniform updates are picked up in the material.

<Tip type="info">
  TSL has an `oscSine` function that oscillates on time that could be used in the example above.
  Using a `time` uniform and `useTask` is for demonstration purposes.
</Tip>
