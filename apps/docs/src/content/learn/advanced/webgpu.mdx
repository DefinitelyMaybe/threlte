---
category: Advanced
title: WebGPU and TSL
order: 1
---

<Tip type="warning">
  WebGPU support in Three.js is still in an early stage and the implementation may change from
  Three.js version to version. This guide is based on Three.js r169.
</Tip>

## WebGPU

To use three.js's WebGPU renderer, import it and then initialize it within your `<Canvas>`'s `createRenderer` prop.

<Tip type="note">
  WebGPU is still an experimental browser api and at the time of writing has 73% global
  [support](https://caniuse.com/?search=webgpu). For this reason, three.js's webgpu renderer
  fallbacks to webgl when webgpu is not available.
</Tip>

```svelte title="App.svelte" {4}+ {8-14}+
<script>
  import Scene from './Scene.svelte'
  import { Canvas } from '@threlte/core'
  import * as THREE from 'three/webgpu'
</script>

<Canvas
  createRenderer={(canvas) => {
    return new THREE.WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
  }}
>
  <Scene />
</Canvas>
```

<Tip type="tip">
  This same approach can be used to swap out the default renderer for any other custom renderer.
</Tip>

<Example path="renderers/WebGPU" />

<small>
  Adapted from [this Three.js
  example](https://threejs.org/examples/?q=webgpu#webgpu_performance_renderbundle).
</small>

### Use consistent imports

Since [Three.js r167](https://github.com/mrdoob/three.js/releases/tag/r167),
Three.js provides a dedicated WebGPU build, available as `three/webgpu`.
Whenever you're targeting WebGPU, you should always import the WebGPU build
instead of the default `three` build:

```ts {1}- {2}+
import * as THREE from 'three'
import * as THREE from 'three/webgpu'
```

### Extend the catalogue

By default `<T>` doesn't know about the extra WebGPU classes and will
error when trying to use the new materials like `<T.MeshPhysicalNodeMaterial />`. You can give `<T>`
the new classes using the [`extend`](/docs/reference/core/t#extending-the-default-component-catalogue)
function.

```svelte title="App.svelte" {3}+ {6}+
<script>
  import Scene from './Scene.svelte'
  import { Canvas, extend } from '@threlte/core'
  import * as THREE from 'three/webgpu'

  extend(THREE)
</script>

<Canvas
  createRenderer={(canvas) => {
    return new THREE.WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
  }}
>
  <Scene />
</Canvas>
```

### Vite

The WebGPURenderer uses top-level async to determine WebGPU compatibility. Vite
will often throw an error when it detects top level await.

To circumvent this issue, the following can be added to your Vite config.

```js
// vite.config.js
optimizeDeps: {
  esbuildOptions: {
    target: 'esnext'
  }
},
build: {
  target: 'esnext'
}
```

Alternatively,
[`vite-plugin-top-level-await`](https://github.com/Menci/vite-plugin-top-level-await)
can be used, although less success has been reported with this method.

## TSL

A question that comes up often in ThreeJS development is "How do I extend ThreeJS's materials?".
External libraries such as [three-custom-shader-material](https://www.npmjs.com/package/three-custom-shader-material)
use a find and replace solution to get this job done. ThreeJS has identified
that it's not an ideal solution and recommends using the [ThreeJS Shading Language](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language) or TSL for short.

The example below is an adaptation of [this](https://threejs.org/examples/?q=tsl#webgpu_tsl_angular_slicing)
ThreeJS example. There are many more [TSL examples](https://threejs.org/examples/?q=tsl)
within three.js that you can use or adapt for your project.

<Example path="shaders/slice/main" />

### Nodes

The [nodes](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#nodematerial) can be directly assigned like any other prop on the `<T>` component.

```svelte
<T.MeshPhysicalNodeMaterial
  outputNode={Fn(([arg1, arg2]) => {
    /* ... */
  })(arg1, arg2)}
  shadowNode={Fn(([arg1, arg2]) => {
    /* ... */
  })(arg2, arg2)}
/>
```

Node materials give you the ability to modify three's builtin materials.
In the sliced gear example, two nodes are modified; the `outputNode` and the `shadowNode`.
The `outputNode` is set up in such a way that it discards any fragments that are
outside the permitted `startAngle` and `arcAngle`. If a fragment is not discarded and
it is not front-facing, it is assigned the color in the `color` uniform. The material
needs its `side` set to `THREE.DoubleSide` otherwise threejs will cull them out if they are facing away
from the camera,

Any fragment that is discarded in the shadowNode will not cast shadows.

### Updating Uniforms

If your node uses uniforms, they can be declared in the `script` tag of
the component and updated via `$effect` or a callback.

For example, if your material uses elapsed time in a uniform, you can update the
uniform inside a `useTask` callback.

The material in the example below demonstrates two ways to update uniforms. The `uTime` uniform
is updated in `useTask` whereas `uIntensity` is updated in an `$effect`.

<Example path="shaders/slice/updatingUniforms" />

<Tip type="info">
  Note that TSL has an
  [`oscSine`](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#oscillator) function
  that oscillates on time that could also be used in the example above.
</Tip>
