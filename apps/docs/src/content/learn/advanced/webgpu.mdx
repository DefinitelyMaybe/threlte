---
category: Advanced
title: WebGPU and TSL
order: 1
---

<Tip type="warning">
  WebGPU support in Three.js is still in an early stage and is subject to change from Three.js
  version to version.
</Tip>
<Tip type="warning">
  We highly recommend targeting [version r171](https://github.com/mrdoob/three.js/releases/tag/r171)
  onwards because of potential [duplication and configuration
  issues](https://github.com/mrdoob/three.js/pull/29404).
</Tip>
## WebGPU

To use Three.js's WebGPU renderer, import it and then initialize it within your
`<Canvas>`'s `createRenderer` prop.

```svelte title="App.svelte" {4}+ {8-14}+
<script>
  import Scene from './Scene.svelte'
  import { Canvas } from '@threlte/core'
  import { WebGPURenderer } from 'three/webgpu'
</script>

<Canvas
  createRenderer={(canvas) => {
    return new WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
  }}
>
  <Scene />
</Canvas>
```

<Tip type="note">
  WebGPU is still an experimental browser api and at the time of writing has [limited availability
  across major browsers](https://caniuse.com/?search=webgpu). For this reason, Three.js's webgpu
  renderer fallbacks to webgl when webgpu is not available.
</Tip>
<Tip type="tip">
  This same approach can be used to swap out the default renderer for any other custom renderer.
</Tip>

<Example path="renderers/WebGPU" />

<small>
  Adapted from [this Three.js
  example](https://threejs.org/examples/?q=webgpu#webgpu_performance_renderbundle).
</small>

The WebGPU renderer doesn't immediately render. If the renderer you provide needs to delay renderering, you
can defer rendering by initially setting the renderMode to `manual` like so:

```svelte title="App.svelte"
<script>
  import { Canvas, T } from '@threlte/core@next'
  import { WebGPURenderer } from 'three/webgpu'
  let renderMode = $state('manual')
</script>

<Canvas
  {renderMode}
  createRenderer={(canvas) => {
    const renderer = new WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
    renderer.init().then(() => {
      renderMode = 'on-demand'
    })
    return renderer
  }}
>
  <Scene />
</Canvas>
```

### Vite

WebGPU uses top-level async to determine WebGPU compatibility. Vite
will often throw an error when it detects this.

To circumvent this issue, the following can be added to your Vite config.

```js
// vite.config.js
optimizeDeps: {
  esbuildOptions: {
    target: 'esnext'
  }
},
build: {
  target: 'esnext'
}
```

Alternatively,
[`vite-plugin-top-level-await`](https://github.com/Menci/vite-plugin-top-level-await)
can be used, although less success has been reported with this method.

## TSL

A question that comes up often in Three.js development is "How do I extend Three.js's materials?".
External libraries such as [three-custom-shader-material](https://www.npmjs.com/package/three-custom-shader-material)
use a find and replace solution to get this job done. Three.js has identified
that it's not an ideal solution and recommends using the [Three.js Shading Language](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language) or TSL for short.

The example below is an adaptation of [this](https://threejs.org/examples/?q=tsl#webgpu_tsl_angular_slicing)
Three.js example. There are many more [TSL examples](https://threejs.org/examples/?q=tsl)
within Three.js that you can use or adapt for your project.

<Example path="shaders/slice/main" />

### Extend the catalogue

By default `<T>` doesn't know about the new material classes and will
error on `<T.MeshPhysicalNodeMaterial />`. You can give `<T>`
the new classes in `three/webgpu` by using the [`extend`](/docs/reference/core/t#extending-the-default-component-catalogue)
function.

```svelte title="App.svelte" {3-4}+ {6}+
<script>
  import Scene from './Scene.svelte'
  import { Canvas, extend } from '@threlte/core'
  import * as THREE from 'three/webgpu'

  extend(THREE)
</script>

<Canvas
  createRenderer={(canvas) => {
    return new THREE.WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
  }}
>
  <Scene />
</Canvas>
```

### Nodes

The [nodes](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#nodematerial) can be directly assigned like any other prop on the `<T>` component.

```svelte
<T.MeshPhysicalNodeMaterial
  outputNode={Fn(([arg1, arg2]) => {
    /* ... */
  })(arg1, arg2)}
  shadowNode={Fn(([arg1, arg2]) => {
    /* ... */
  })(arg2, arg2)}
/>
```

Node materials give you the ability to modify three's builtin materials.
In the sliced gear example, two nodes are modified; the `outputNode` and the `shadowNode`.
The `outputNode` is set up in such a way that it discards any fragments that are
outside the permitted `startAngle` and `arcAngle`. If a fragment is not discarded and
it is not front-facing, it is assigned the color in the `color` uniform. The material
needs its `side` set to `THREE.DoubleSide` otherwise three.js will cull them out if they are facing away
from the camera,

Any fragment that is discarded in the shadowNode will not cast shadows.

### Updating Uniforms

If your node uses uniforms, they can be declared in the `script` tag of
the component and updated via `$effect` or a callback.

For example, if your material uses elapsed time in a uniform, you can update the
uniform inside a `useTask` callback.

The material in the example below demonstrates two ways to update uniforms. The `uTime` uniform
is updated in `useTask` whereas `uIntensity` is updated in an `$effect`.

<Example path="shaders/slice/updatingUniforms" />

<Tip type="info">
  Note that TSL has an
  [`oscSine`](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#oscillator) function
  that oscillates on time that could also be used in the example above.
</Tip>
