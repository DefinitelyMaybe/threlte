---
category: Advanced
title: Creating UI
order: 2
---

Very often you'd like to create some toggleable scene state, display the values
of a three.js vector or see a T component variable within plain HTML.

## Easiest Example

A library to help get started with this is
[svelte-tweakpane-ui](https://kitschpatrol.com/svelte-tweakpane-ui) and is used
across many examples within these docs. Our examples also tend to be simple
enough that just passing parent state to child props works well; i.e.
`App.svelte` to `Scene.svelte`. If that works for you, good, keep using that.

<Example path="extras/environment/basic" />

The rest of this page is about when that doesn't work well enough and what your
other options are.

## Prop drilling

Passing down props may not always be the best solution. For instance, as soon
as the relationship becomes distant i.e. ansector, ..., child. To share the
ancestors state props the same way requires passing it through all intermediate
components within the component tree which can easily become tedious to work
with or refactor.

## Context API

The [context
API](https://svelte.dev/docs/svelte/$state#Passing-state-across-modules) is a
better option for distant components and is used extensively acrossly Threlte.
Anytime you make a [`useThrelte`](/docs/reference/core/use-threlte) call, the
context API is being used.

To create some reactive state for your UI, mix it with a svelte store like
[writable](https://svelte.dev/docs/svelte/svelte-store#writable), Threlte's
[currentWritable](/docs/reference/core/utilities#currentwritable), a `const`
`$state({})` rune or encapsulate `$state()` within a
[class](https://svelte.dev/docs/svelte/$state#Classes).

<Tip
  type="tip"
  title="Type Safety"
>
  To add type safety to your context, [wrap the context
  calls](https://svelte.dev/docs/svelte/context#Type-safe-context).
</Tip>

### Writable example

```svelte title="App.svelte"
<script lang="ts">
  import { Canvas } from '@threlte/core'
  import Scene from '$lib/Scene.svelte'
  import { setContext } from 'svelte'
  import { writable } from 'svelte/store'

  let { debug } = setContext('state', { debug: writable(false) })
</script>

<input
  type="checkbox"
  name="debug"
  id="debug"
  bind:checked={$debug}
/>

<div>
  <Canvas>
    <Scene />
  </Canvas>
</div>
```

```svelte title="Descendant.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
  import { getContext } from 'svelte'

  let { debug } = getContext('state')
</script>

<T.Mesh>
  <T.BoxGeometry />
  <T.MeshStandardMaterial
    wireframe={$debug}
    color="red"
  />
</T.Mesh>
```

### Runes example

This currently doesn't work off the bat. The descendant doesn't update.

```svelte title="App.svelte"
<script lang="ts">
  import { Canvas } from '@threlte/core'
  import Scene from '$lib/Scene.svelte'
  import { setContext } from 'svelte'

  const state = $state({
    debug: false
  })

  setContext('state', state)
</script>

<input
  type="checkbox"
  name="debug"
  id="debug"
  bind:checked={state.debug}
/>

<div>
  <Canvas>
    <Scene />
  </Canvas>
</div>
```

```svelte title="Descendant.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
  import { getContext } from 'svelte'

  let state = getContext('state')

  // works if this gets added
  // $inspect(state.debug)
</script>

<T.Mesh>
  <T.BoxGeometry />
  <T.MeshStandardMaterial
    wireframe={state.debug}
    color="red"
  />
</T.Mesh>
```

### Class example

This currently doesn't work off the bat. The descendant doesn't update.

```svelte title="App.svelte"
<script lang="ts">
  import { Canvas } from '@threlte/core'
  import Scene from '$lib/Scene.svelte'
  import { setContext } from 'svelte'

  class State {
    debug = $state(false)
  }

  let { debug } = setContext('state', new MyState())
</script>

<input
  type="checkbox"
  name="debug"
  id="debug"
  bind:checked={state.debug}
/>

<div>
  <Canvas>
    <Scene />
  </Canvas>
</div>
```

```svelte title="Descendant.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
  import { getContext } from 'svelte'

  let state = getContext('state')

  // works if this gets added
  // $inspect(state.debug)
</script>

<T.Mesh>
  <T.BoxGeometry />
  <T.MeshStandardMaterial
    wireframe={state.debug}
    color="red"
  />
</T.Mesh>
```

## Shared state

Another option for distant components is by using [shared
state](https://svelte.dev/docs/svelte/$state#Passing-state-across-modules).
This option is similar to the context API but instead you're dealing more
directly with the data.

A separate `state.svelte.ts` file which exports `$state()` that is used by each
component.

Start with creating the shared state file.

```typescript title="shared.svelte.ts"
export const globals = $state({
  debug: false,
  vec1: [0, 0, 0],
  vec2: new Vector3(0, 0, 0)
  // etc...
})
```
