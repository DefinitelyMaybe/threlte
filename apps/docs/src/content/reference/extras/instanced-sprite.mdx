---
{
  order: 3,
  category: '@threlte/extras',
  sourcePath: 'packages/extras/src/lib/components/InstancedSprite/InstancedSprite.svelte',
  name: <InstancedSprite>,
  type: 'component',
  componentSignature:
    {
      props:
        [
					{
            name: 'alphaTest',
            type: 'number',
            required: false,
            default: '0.1',
            description: 'Sets the alpha value to be used when running an alpha test.'
          },
					{
            name: 'autoUpdate',
            type: 'boolean',
            required: false,
            default: 'true',
            description: 'Update animations automatically every frame'
          },
					{
            name: 'baseMaterial',
            type: 'typeof MeshBasicMaterial | typeof MeshStandardMaterial | typeof MeshLambertMaterial | typeof MeshPhongMaterial',
            required: false,
            default: 'typeof MeshBasicMaterial',
            description: 'Base material used to construct the sprite material.'
          },
					{
            name: 'billboarding',
            type: 'boolean',
            required: false,
            default: 'typeof MeshBasicMaterial',
            description: 'Sets the default global billboarding state that is used unless the setAt was called on the instance.'
          },
					{
            name: 'count',
            type: 'number',
            required: true,
            description: 'Number of instances'
          },
					{
            name: 'filter',
            type: "'nearest' | 'linear'",
            required: false,
            default: "'nearest'",
            description: 'The texture filtering applied to the spritesheet.'
          },
          {
            name: 'fps',
            type: 'boolean',
            required: false,
            default: '10',
            description: 'The desired frames per second of the animation.'
          },
					{
            name: 'playmode',
            type: '"FORWARD" | "REVERSE" | "PAUSE" | "PINGPONG"',
            required: false,
            default: '"FORWARD"',
            description: 'Sets playmode for all instances'
          },
					{
            name: 'transparent',
            type: 'boolean',
            required: false,
            default: 'true',
            description: 'Whether or not the material should be transparent.'
          },
        ],
      events:
        [
          {
            name: 'load',
            payload: 'void',
            description: 'Fires when all resources have loaded.'
          }
        ],
      bindings:
        [
          { name: ref, type: 'InstancedSpriteMesh' }
        ]
    }
}
---

<Tip type="experimental">Early version. Features and API might change significantly over time. Please report any issues you encounter on Discord or Github.</Tip>

<Example path="extras/instanced-sprite" />


## Basic example
To use the `<InstancedSprite>` you must provide it with sprite metadata and a texture. While we recommend utilizing the
[`buildSpritesheet()`](#buildSpritesheet) utility for this purpose, you are also free to implement your own
custom solution, provided it meets the component's input requirements.

**1. Sprite metadata object**

```svelte title=Flyer.svelte
<script lang="ts">
  import { InstancedSprite, buildSpritesheet } from '@threlte/extras'
  import UpdaterFlying from './UpdaterFlying.svelte'
  import type { SpritesheetMetadata } from '@threlte/extras'


  const demonSpriteMeta = [
    {
      url: '/textures/sprites/cacodaemon.png',
      type: 'rowColumn',
      width: 8,
      height: 4,
      animations: [
        { name: 'fly', frameRange: [0, 5] },
        { name: 'attack', frameRange: [8, 13] },
        { name: 'idle', frameRange: [16, 19] },
        { name: 'death', frameRange: [24, 31] }
      ]
    }
  ] as const satisfies SpritesheetMetadata

  const flyerSheetbuilder = buildSpritesheet.from<typeof demonSpriteMeta>(demonSpriteMeta)
</script>
```

In this example, there is a single sprite image containing 4 different animations. The metadata is contained within the
`demonSpriteMeta` object, which describes the layout and animation details of the spritesheet.

In this case, the spritesheet image is arranged in a grid of 4 rows and 8 columns, so the `type` is set to `'rowColumn'`,
`height` to `4` (indicating the number of rows), and `width` to `8` (representing the number of columns).
The `animations` property is an array, where each element represents a separate animation with a `name` and a `frameRange`.

For detailed information on defining animations and using frame ranges, refer to the [Spritesheet builder section](#spritesheetmetadata-object)

**2. Adding component to the scene**

```svelte title=Flyer.svelte
{#await flyerSheetbuilder.spritesheet then spritesheet}
  <InstancedSprite
    count={20000}
    {spritesheet}
  >
	<!-- User component for updating instances -->
    <UpdaterFlying /> /
	<!-- -->
  </InstancedSprite>
{/await}
```

We add `<InstancedSprite>` to the scene with a `count` `spritesheet` - the only required props. Spritesheet is a result of the promise from the previous step.

To add the `<InstancedSprite>` component to the scene, you need to specify at least two essential properties:
`count` and `spritesheet`. The `spritesheet` property is the object obtained as the result of awaiting the Promise of the `buildSpritesheet` function called earlier.


**3. Updating instances**

In our example, the user made `<UpdaterFlying>` component is responsible for updating sprites.
This component leverages the `useInstancedSprite()` hook, which makes it easy to access and
adjust sprite properties such as position and animation.

To update sprite instances, we utilize the `useTask` hook. Inside, a loop iterates over the IDs
of all instances, applying updates to their positions and assigning the fly animation to each.
This description is simplified for brevity, this is where you'd have your complex movement or game logic.
A working example, demonstrating basic random movement, is available in the source of the live example for this component
(UpdaterFlying.svelte, UpdaterWalking.svelte, UpdaterFlyingHook.svelte).


```svelte title=UpdaterFlying.svelte
<script lang="ts">
	import { useTask } from '@threlte/core'
	import { useInstancedSprite } from '@threlte/extras'

	const { updatePosition, count, animationMap, sprite } = useInstancedSprite()

	useTask(()=>{
		for(let i=0; i<count;i++){
			updatePosition(i, [0,0,0])
			sprite.animation.setAt(i, 'fly')
		}
	})
</script>
```


## Spritesheet builder

### SpritesheetMetadata object

Object used in `buildSpritesheet` function has to be compliant with the `SpritesheetMetadata` type format. This type is structured to
accommodate the metadata for one or multiple sprite files within a single spritesheet.

```ts
type SpritesheetMetadata = {
  url: string
  type: 'rowColumn' | 'frameSize'
  width: number
  height: number
  animations: {
    name: string
    frameRange: [number, number]
  }[]
}[]

```

#### Understanding SpritesheetMetadata:

- **Array Structure**: Given that the utility function is designed to combine multiple sprite files into a single spritesheet,
`SpritesheetMetadata` is an array. Each element in this array corresponds to a separate file's metadata.
For a single sprite image, the array will contain only one item. For multiple images, the array will include an entry for each.

- **Metadata Fields**. Each sprite file entry in the array needs:
	- `url`: Specifies the path or URL to the sprite image file.
	- `type`: Determines the method of defining the spritesheet dimensions. Type `"rowColumn"` specifies the layout in terms of rows
	and columns within the image, and type `"frameSize"` instead defines the size of each frame, allowing the utility to calculate the layout.
	- `width` and `height`: Depending on type, these refer to the number of `columns` and `rows` (`"rowColumn"`) or the dimensions of a single frame (`"frameSize"`).
	- `animations`: An array detailing the animations, where each animation has a name and a `frameRange`. The `frameRange` is a tuple
	marking the start and end frames of the animation.

Since our utility function can combine multiple files into a same spritesheet, the `SpritesheetMetadata` is an Array of declarations,
each for one file. So if we use one sprite image, the array will have a length of one and if we use multiple files the array will have
multiple entries.

Each sprite file entry in the array needs:
- **`url`** - The URL or path to the image file.
- **`type`** - choose whether youâ€™re providing how many rows and columns are in an image `"rowColumn"` or giving the size of a single
 frame for the builder to interpolate from `"frameSize"`
- `width` and `height` that refer to either column and row or imageWidth and imageHeight depending on what you chose in `type`
- `animations` - an array of animations with `name` string and `frameRange` - an array of two number that declares from which
frameId animation starts and to which frameId the animation runs.

#### Understanding SpritesheetMetadata:

For improved developer experience when working with TypeScript, it is strongly recommended to use `as const` assertion in
combination with `satisfies SpritesheetMetadata`. This approach not only ensures compliance with the `SpritesheetMetadata`
type but also enables autocompletion for animation names within utility functions, which is highly recommended:


### `buildSpritesheet()`

`buildSpritesheet()` is a utility function for building a final texture and spritesheet object from a provided `SpritesheetMetadata` object or external source.
Each `buildSpritesheet` method return an Promise that and has to be awaited. Promise returned by each method contains an object with a `spritesheet`
ready for use in `<InstancedSprite>`.

#### buildSpritesheet().from(meta: SpritesheetMetadata)
Other than `spritesheet` promise, it also returns a `useInstancedSprite` hook. This hook can be enhanced with
extra typescript support for autocompletion of animation names as such:


```ts
 const meta = [
    {
      url: '/textures/sprites/cacodaemon.png',
      type: 'rowColumn',
      width: 8,
      height: 4,
      animations: [
        { name: 'fly', frameRange: [0, 5] },
        { name: 'attack', frameRange: [8, 13] },
        { name: 'idle', frameRange: [16, 19] },
        { name: 'death', frameRange: [24, 31] }
      ]
    }
  ] as const satisfies SpritesheetMetadata

  const result = buildSpritesheet.from<typeof meta>(meta)
```

![Tree sprite atlas](/images/docs/extras/instanced-sprite/useInstancedSpriteAutocomplete.png)

#### buildSpritesheet().fromAseprite(asepriteDataUrl: string, spriteImageUrl: string)

Similar to above, but it parses the Aseprite metadata json into the correct format.
Does not provide any additional utilities.

### Examples

**Example A: one sprite file with multiple animations.**

```ts
const demonSpriteMeta = [
    {
      url: '/textures/sprites/cacodaemon.png',
      type: 'rowColumn',
      width: 8,
      height: 4,
      animations: [
        { name: 'fly', frameRange: [0, 5] },
        { name: 'attack', frameRange: [8, 13] },
        { name: 'idle', frameRange: [16, 19] },
        { name: 'death', frameRange: [24, 31] }
      ]
    }
  ] as const satisfies SpritesheetMetadata
```

**Example B: multiple sprite files with one animation each.**
```ts
const goblinSpriteMeta = [
    {
      url: '/textures/sprites/goblin/Attack.png',
      type: 'rowColumn',
      width: 8,
      height: 1,
      animations: [{ name: 'attack', frameRange: [0, 7] }]
    },
    {
      url: '/textures/sprites/goblin/Death.png',
      type: 'rowColumn',
      width: 4,
      height: 1,
      animations: [{ name: 'death', frameRange: [0, 3] }]
    },
    {
      url: '/textures/sprites/goblin/Idle.png',
      type: 'rowColumn',
      width: 4,
      height: 1,
      animations: [{ name: 'idle', frameRange: [0, 3] }]
    }
  ] as const satisfies SpritesheetMetadata
```

## Updating instances

Instances can be updated by using methods provided by the `InstancedSpriteMesh`. You can access it in two primary ways:

- Utilizing the `useInstancedSprite()` hook (recommended approach).
- Directly with the `ref` prop binding on the component.


### `useInstancedSprite()`

```ts
	import { useInstancedSprite } from '@threlte/extras'

  const hook = useInstancedSprite()
	// it's useful to immediately destructure it like this
  const { updatePosition, count, animationMap, sprite } = useInstancedSprite()
```

	- `sprite`: Provides direct access to the `InstancedSpriteMesh`, enabling updates to instance properties such as animations, billboarding, and play mode.
	- `count`: Total number of instances.
	- `updatePosition(id: number, position: Vector3Tuple, scale?: Vector2Tuple)`: A utility function for updating an instance's position and scale.
	- `animationMap`: A writable store (`Writable<Map<string, number>>`) that maps animation names to their corresponding IDs.
	Animation names are useful to have for setting a random animation from a pool etc. The IDs are reserved for more advanced usecases.

#### Typescript support

The useInstancedSprite hook supports typing for autocompletion of animation names:

```ts
	type AnimationNames = 'walk' | 'run' | 'idle' | 'fly'
  const { updatePosition, count, animationMap, sprite } = useInstancedSprite<AnimationNames>()
```

This is how the [buildSpritesheet.from](#buildspritesheet) utility works. It processes animation names from a complex
object structure into a simplified type like the one above.


### `<Instance>`

Instance is a slot prop component that is used to update sprite instances properties. You can gain access to it with `let:Instance` on `InstancedSprite` component.
Then put it as a child component. The only required property is `id`. It also has `position` of type `Vector3Tuple` prop and `scale` of type `Vector2Tuple`.

Other than this, it as other properties that you can find in the `InstancedSpriteMesh`, so: `animationName`, `playmode`, `billboarding`, `offset`, `loop`,
`flipX`, `flipY`, `frameId`. Read more about them in the [InstancedSpriteMesh](#instancedspritemesh) section

The `<Instance>` component serves as a declarative alternative to `useInstancedSprite` hook to dynamically update the properties of sprite instances within the
`InstancedSprite` component. You can access through the `let:Instance` directive.

*Example: Set a position, scale and flipX for every instance.*
```svelte
<InstancedSprite
  count={10000}
  {spritesheet}
  let:Instance
>
  {#each { length: 10000 } as _, i}
    <Instance
      position={[Math.random()*100, Math.random()*100, Math.random()*100]}
      scale={[3, 3]}
			flipX
      id={i}
    />
  {/each}
</InstancedSprite>
```


## InstancedSpriteMesh

The `InstancedSpriteMesh` is the foundation behind the `<InstancedSprite>` component, written to enableefficient instancing of animated sprites within a
Three.js environment. By extending the capabilities of the [troika's InstancedUniformsMesh](https://protectwise.github.io/troika/three-instanced-uniforms-mesh/).
For an in-depth exploration of `InstancedSpriteMesh` and its features, refer to the documentation available at
[InstancedSpriteMesh docs](https://three-kit.vercel.app/instancedsprite/01-instanced-sprite-mesh/).

`InstancedSpriteMesh` provides a suite of methods designed to offer granular control over the
animation and properties of sprite instances:

### animation
  - **.animation.setAt( instanceId: number, animation: string )** - sets animation (by name) on instanceId

### playmode
```ts
type PLAY_MODE = "FORWARD" | "REVERSE" | "PAUSE" | "PINGPONG"

```
	- **.playmode.setAt(instanceId: number, playmode: PLAY_MODE)** - set playmode for one instance
	- **.playmode.setAll(playmode: PLAY_MODE)** - set playmode for all instances

### billboarding
  Set of methods to toggle billboarding
  - **.billboarding.setAt( instanceId: number, enable: boolean )** - enables billboarding on instance
  - **.billboarding.setAll( enable: boolean )** - sets default global billboarding state that is used unless the `setAt` was called on the instance
  - **.billboarding.unsetAll()** - removes all instance specific billboarding settings

### offset
  Offset sprite animation time by a given number of milliseconds
  - **.offset.setAt: (instanceId: number, offset: number)**
  - **.offset.randomizeAll: (scalar: number = 1)** - offset all sprites by a random value (0-1) multiplied by scalar

### frame
  - **.frame.setAt: (instanceId: number, frameId: number, animation?: string)** - Set the instance at a specific frame. FrameID is an n-th frame in the animation if the name is provided, otherwise if not set, it's an n-th frameId of the entire spritesheet.

### loop
  methods to control whether sprite animation should be looped
  - **.loop.setAt( instanceId: number, enable: boolean )** - sets per instance loop mode
  - **.loop.setAll( enable: boolean )** - changes looping mode in all instances


### flipX
  - **.flipX.setAt(instanceId: number, flipX: boolean)**
  - **.flipX.setGlobal(flipX: boolean)**
  - **.flipX.unsetAll()**

### flipY
  - **.flipY.setAt(instanceId: number, flipY: boolean)**
  - **.flipY.setGlobal(flipY: boolean)**
  - **.flipY.unsetAll()**

### play
Utility function that combines `.animation`, `.loop` and `.playmode`
```ts
play(
  animation: V,
  loop: boolean = true,
  playmode: PLAY_MODE = "FORWARD")
.at(instanceId: number)

```

### update
 - **.update()** - manually updates instanced spritesheet animation based on fps and time. Not necessary unless `autoUpdate` is set to `false` on the `<InstancedSprite>` component


## Static sprites

This component focuses on targetting animated sprites, but it's possible to use it for static images as well.
If each frame of the spritesheet is a separate animation, then it effectively acts as an atlas with named sprites.

The `<Tree/>` component in the example above does this.
![Tree sprite atlas](/textures/sprites/trees-pixelart.png)

Set `autoUpdate={false}` on static components and only update it manually with `sprite.update()`. This has to be done when the InstancedSprite is initiated or when spritesheet or atlas change.
If you don't do it, then the spritesheet will run animation updates each frame to run animations that don't really exist.
