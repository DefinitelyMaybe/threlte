---
{
  order: 3,
  category: '@threlte/extras',
  sourcePath: 'packages/extras/src/lib/components/InstancedSprite/InstancedSprite.svelte',
  name: <InstancedSprite>,
  type: 'component',
  componentSignature:
    {
      props:
        [
					{
            name: 'alphaTest',
            type: 'number',
            required: false,
            default: '0.1',
            description: 'Sets the alpha value to be used when running an alpha test.'
          },
					{
            name: 'autoUpdate',
            type: 'boolean',
            required: false,
            default: 'true',
            description: 'Update animations automatically every frame'
          },
					{
            name: 'baseMaterial',
            type: 'typeof MeshBasicMaterial | typeof MeshStandardMaterial | typeof MeshLambertMaterial | typeof MeshPhongMaterial',
            required: false,
            default: 'typeof MeshBasicMaterial',
            description: 'Base material used to construct the sprite material.'
          },
					{
            name: 'billboarding',
            type: 'boolean',
            required: false,
            default: 'typeof MeshBasicMaterial',
            description: 'Sets the default global billboarding state that is used unless the setAt was called on the instance.'
          },
					{
            name: 'count',
            type: 'number',
            required: true,
            description: 'Number of instances'
          },
					{
            name: 'filter',
            type: "'nearest' | 'linear'",
            required: false,
            default: "'nearest'",
            description: 'The texture filtering applied to the spritesheet.'
          },
          {
            name: 'fps',
            type: 'boolean',
            required: false,
            default: '10',
            description: 'The desired frames per second of the animation.'
          },
					{
            name: 'playmode',
            type: '"FORWARD" | "REVERSE" | "PAUSE" | "PINGPONG"',
            required: false,
            default: '"FORWARD"',
            description: 'Sets playmode for all instances'
          },
					{
            name: 'transparent',
            type: 'boolean',
            required: false,
            default: 'true',
            description: 'Whether or not the material should be transparent.'
          },
        ],
      events:
        [
          {
            name: 'load',
            payload: 'void',
            description: 'Fires when all resources have loaded.'
          }
        ],
      bindings:
        [
          { name: ref, type: 'InstancedSpriteMesh' }
        ]
    }
}
---

<Tip type="experimental">Experimental warning. The api may change significantly, performance and compatiblity untested on various hardware/OS.</Tip>

<Example path="extras/instanced-sprite" />


## Basic example
The `<InstancedSprite>` component requries a spritesheet metadata and texture to be provided. It's recommended to use a [`buildSpritesheet()`](#buildSpritesheet) utility but you can also use your own custom solution. The most common setup will look something similar to the code below.

**1. Sprite metadata object**

In this example, there is a single sprite image containing 4 different animations. In `demonSpriteMeta` we declare the metadata of the spritesheet. In this case the file is made out of 4 rows and 8 columns of equal sized images, so we say that the spritesheet
type is `'rowColumn'`, `height` (rows) is 4 and `width` (columns) is 8.
Then we declare our `animations` array. Each animation has a `name` and a `frameRange`. You can learn more about this in the [Spritesheet](#spritesheet) section of this page. After the object is ready, we use it as an argument in the `buildSpritesheet.from` utility function, which
returns a Promise with a spritesheet ready to be put into our component.


```svelte title=Flyer.svelte
<script lang="ts">
  import { InstancedSprite, buildSpritesheet } from '@threlte/extras'
  import UpdaterFlying from './UpdaterFlying.svelte'
  import type { SpritesheetMetadata } from '@threlte/extras'


  const demonSpriteMeta = [
    {
      url: '/textures/sprites/cacodaemon.png',
      type: 'rowColumn',
      width: 8,
      height: 4,
      animations: [
        { name: 'fly', frameRange: [0, 5] },
        { name: 'attack', frameRange: [8, 13] },
        { name: 'idle', frameRange: [16, 19] },
        { name: 'death', frameRange: [24, 31] }
      ]
    }
  ] as const satisfies SpritesheetMetadata

  const flyerSheetbuilder = buildSpritesheet.from<typeof demonSpriteMeta>(demonSpriteMeta)
</script>
```

**2. Adding component to the scene**

We add `<InstancedSprite>` to the scene with a `count` `spritesheet` - the only required props. Spritesheet is a result of the promise from the previous step.

```svelte title=Flyer.svelte
{#await flyerSheetbuilder.spritesheet then spritesheet}
  <InstancedSprite
    count={20000}
    {spritesheet}
  >
	<!-- User component for updating instances -->
    <UpdaterFlying /> /
	<!-- -->
  </InstancedSprite>
{/await}
```

**3. Updating instances**

In our example, the user made `<UpdaterFlying>` component is responsible for updating sprites. It makes use of `useInstancedSprite()` hook,
which makes it easy to update position, animations etc. Then, inside of a `useTask` we loop over all instance `id`s and update their
position and set animation to `fly`. This is simplified for brevity, but you can see a full implementation of basic random movement
in the main example on top of this page.
This is not the only way to update instances. There is also an `<InstanceComponent>` and a typed version of `useInstancedSprite` -
see how to use them in [Updating instances](#updating-instances)


```svelte title=UpdaterFlying.svelte
<script lang="ts">
	import { useTask } from '@threlte/core'
	import { useInstancedSprite } from '@threlte/extras'

	const { updatePosition, count, animationMap, sprite } = useInstancedSprite()

	useTask(()=>{
		for(let i=0; i<count;i++){
			updatePosition(i, [0,0,0])
			sprite.animation.setAt(i, 'fly')
		}
	})
</script>
```




## Spritesheet builder

### SpritesheetMetadata object

Object used in `buildSpritesheet` function has to be compliant with the `SpritesheetMetadata` type format:

```ts
type SpritesheetMetadata = {
  url: string
  type: 'rowColumn' | 'frameSize'
  width: number
  height: number
  animations: {
    name: string
    frameRange: [number, number]
  }[]
}[]

```

Since our utility function can combine multiple files into a same spritesheet, the `SpritesheetMetadata` is an Array of declarations, each for one file.
So if we use one sprite image, the array will have a length of one and if we use multiple files the array will have multiple entries.

Each sprite file entry in the array needs:
- **`url`** - The URL or path to the image file.
- **`type`** - choose whether youâ€™re providing how many rows and columns are in an image `"rowColumn"` or giving the size of a single frame for the builder to interpolate from `"frameSize"`
- `width` and `height` that refer to either column and row or imageWidth and imageHeight depending on what you chose in `type`
- `animations` - an array of animations with `name` string and `frameRange` - an array of two number that declares from which frameId animation starts and to which frameId the animation runs.

Instead of making the object type `SpritesheetMetadata` you can use `as const satisfies SpritesheetMetadata` which will allow for animation name autocompletion in utility hook (recommended).

**Example: one sprite file with multiple animations.**
```ts
const demonSpriteMeta = [
    {
      url: '/textures/sprites/cacodaemon.png',
      type: 'rowColumn',
      width: 8,
      height: 4,
      animations: [
        { name: 'fly', frameRange: [0, 5] },
        { name: 'attack', frameRange: [8, 13] },
        { name: 'idle', frameRange: [16, 19] },
        { name: 'death', frameRange: [24, 31] }
      ]
    }
  ] as const satisfies SpritesheetMetadata
```

**Example: Multiple sprite files with one animation each.**
```ts
const goblinSpriteMeta = [
    {
      url: '/textures/sprites/goblin/Attack.png',
      type: 'rowColumn',
      width: 8,
      height: 1,
      animations: [{ name: 'attack', frameRange: [0, 7] }]
    },
    {
      url: '/textures/sprites/goblin/Death.png',
      type: 'rowColumn',
      width: 4,
      height: 1,
      animations: [{ name: 'death', frameRange: [0, 3] }]
    },
    {
      url: '/textures/sprites/goblin/Idle.png',
      type: 'rowColumn',
      width: 4,
      height: 1,
      animations: [{ name: 'idle', frameRange: [0, 3] }]
    }
  ] as const satisfies SpritesheetMetadata
```


### Builder

`buildSpritesheet()` is a utility function for building a final texture and spritesheet object from a provided `SpritesheetMetadata` object or external source.
Each `buildSpritesheet` method return an Promise that and has to be awaited. Promise returned by each method contains an object with a `spritesheet`
ready for use in `<InstancedSprite>`.

#### buildSpritesheet().from(meta: SpritesheetMetadata)
Other than `spritesheet` promise, it also returns a `useInstancedSprite` hook. This hook can be enhanced with
extra typescript support for autocompletion of animation names as such:

![Tree sprite atlas](/images/docs/extras/instanced-sprite/useInstancedSpriteAutocomplete.png)

```ts
 const meta = [
    {
      url: '/textures/sprites/cacodaemon.png',
      type: 'rowColumn',
      width: 8,
      height: 4,
      animations: [
        { name: 'fly', frameRange: [0, 5] },
        { name: 'attack', frameRange: [8, 13] },
        { name: 'idle', frameRange: [16, 19] },
        { name: 'death', frameRange: [24, 31] }
      ]
    }
  ] as const satisfies SpritesheetMetadata

  const result = buildSpritesheet.from<typeof meta>(meta)
```

#### buildSpritesheet().fromAseprite(asepriteDataUrl: string, spriteImageUrl: string)

Similar to above, but it parses the Aseprite metadata json into the correct format.
Does not provide any additional utilities.

## `useInstancedSprite()`

## `<Instance>`

## Updating instances

You can update instances by calling the below functions of the underlying `InstancedSpriteMesh`. You can access it via:
- [useInstancedSprite() hook](#instanced-sprite#useinstancedsprite) (recommended)
- `ref` prop of the component

### animation
  - **.animation.setAt( instanceId: number, animation: string )** - sets animation (by name) on instanceId

### playmode

```ts
type PLAY_MODE = "FORWARD" | "REVERSE" | "PAUSE" | "PINGPONG"

```
	- **.playmode.setAt(instanceId: number, playmode: PLAY_MODE)** - set playmode for one instance
	- **.playmode.setAll(playmode: PLAY_MODE)** - set playmode for all instances

### billboarding
  Set of methods to toggle billboarding
  - **.billboarding.setAt( instanceId: number, enable: boolean )** - enables billboarding on instance
  - **.billboarding.setAll( enable: boolean )** - sets default global billboarding state that is used unless the `setAt` was called on the instance
  - **.billboarding.unsetAll()** - removes all instance specific billboarding settings

### offset
  Offset sprite animation time by a given number of milliseconds
  - **.offset.setAt: (instanceId: number, offset: number)**
  - **.offset.randomizeAll: (scalar: number = 1)** - offset all sprites by a random value (0-1) multiplied by scalar

### frame
  - **.frame.setAt: (instanceId: number, frameId: number, animation?: string)** - Set the instance at a specific frame. FrameID is an n-th frame in the animation if the name is provided, otherwise if not set, it's an n-th frameId of the entire spritesheet.

### loop
  methods to control whether sprite animation should be looped
  - **.loop.setAt( instanceId: number, enable: boolean )** - sets per instance loop mode
  - **.loop.setAll( enable: boolean )** - changes looping mode in all instances


### flipX
  - **.flipX.setAt(instanceId: number, flipX: boolean)**
  - **.flipX.setGlobal(flipX: boolean)**
  - **.flipX.unsetAll()**

### flipY
  - **.flipY.setAt(instanceId: number, flipY: boolean)**
  - **.flipY.setGlobal(flipY: boolean)**
  - **.flipY.unsetAll()**

### play
Utility function that combines `.animation`, `.loop` and `.playmode`
```ts
play(
  animation: V,
  loop: boolean = true,
  playmode: PLAY_MODE = "FORWARD")
.at(instanceId: number)

```

### update
 - **.update()** - manually updates instanced spritesheet animation based on fps and time. Not necessary unless `autoUpdate` is set to `false` on the `<InstancedSprite>` component


## Static sprites

This component focuses on targetting animated sprites, but it's possible to use it for static images as well.
If each frame of the spritesheet is a separate animation, then it effectively acts as an atlas with named sprites.

The `<Tree/>` component in the example above does this.
![Tree sprite atlas](/textures/sprites/trees-pixelart.png)

Set `autoUpdate={false}` on static components and only update it manually with `sprite.update()`. This has to be done when the InstancedSprite is initiated or when spritesheet or atlas change.
If you don't do it, then the spritesheet will run animation updates each frame to run animations that don't really exist.


## Advanced
### How it works
GPGPU, Data texture for user commands

### Triangle geometry
Triangle vs Plane mode - triangle saves vertices but a larger area of the geometry is unused. Fragment discards, z sorting tradeoffs?
