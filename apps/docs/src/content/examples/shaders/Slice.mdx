The example below is an adaptation of [this](https://threejs.org/examples/?q=tsl#webgpu_tsl_angular_slicing) threejs example.

<Example path="shaders/slice/main" />

A question thatlways comes up often in ThreeJS development is "How do I extend ThreeJS's materials?". Most libraries such as [three-custom-shader-material](https://www.npmjs.com/package/three-custom-shader-material) use a find and replace solution. This works well enough but ThreeJS has identified that it's not an ideal solution and recommends using [threejs shading language](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language). One of the primary benefits for using TSL is that the language is renderer-agnostic. This means TSL will compile to either glsl or wgsl code depending on what renderer is being used.

<Tip type="warning">
  At this time webgpu is still a very experimental browser api and is [not widely
  supported](https://caniuse.com/?search=webgpu) For this reason, there are ways to fallback to
  webgl when webgpu is not available.
</Tip>

Threlte easily integrates with node materials from `three/webgu` The first step is to switch to using the `WebGPURenderer`. This is applied at the `Canvas` level.

```svelte
<Canvas
  createRenderer={(canvas) => {
    return new WebGPURenderer({
      antialias: true,
      canvas,
      forceWebGL: false
    })
  }}
>
  <Scene />
</Canvas>
```

The next step is to extend the threlte catalog to use the definitions from `three/webgu`.

```svelte
<script>
  import * as THREE from 'three/webgpu'
  import { extend } from '@threlte/core'

  extend(THREE)
</script>
```

The extensition makes it possible to use class definitions such as `MeshPhysicalNodeMaterial` on `<T>` components.

```svelte
<T.MeshPhysicalNodeMaterial />
```

Node materials give the developer the ability to modify three's builtin materials. In the example above, two nodes are modified; the `outputNode` and the `shadowNode`. The `outputNode` is set up in such a way that it discards any fragments that are outside the permitted `startAngle` and `arcAngle`. If a fragment is not discarded and it is not front-facing, it is assigned the color in the `color` uniform. These are the fragments at the edges of the slice. The `shadowNode` is used for shadows. Any fragment that is discarded in the shadowNode will not cast shadows.

The nodes can be directly assigned like any other prop on the `<T>` component.

```svelte
<T.MeshPhysicalNodeMaterial
  outputNode={Fn(([arg1, arg2]) => {
    /* ... */
  })(arg1, arg2)}
  shadowNode={Fn(([arg1, arg2]) => {
    /* ... */
  })(arg2, arg2)}
/>
```

Various TSL functions such as `If`, `Fn`, and `vec4` can be imported from `three/tsl` or `three/webgpu`

If your node depends on uniforms like the example in the beginning, they can be declared the the `script` tag of the component and updated via `$effect` or callback.

For example, if your shader uses elapsed time in a uniform, you can update the uniform inside a `useTask` callback.

<Example path="shaders/slice/updatingUniforms" />

The material above oscillates the red channel of its emissive color from 0 to 1. This value is then multiplied by the `emissiveIntensity`

<Tip type="info">
  TSL has an `oscSine` function that oscillates on time that could be used in the example above.
  Using a `time` uniform and `useTask` is for demonstration purposes.
</Tip>
