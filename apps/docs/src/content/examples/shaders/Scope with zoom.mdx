<Example path="shaders/useFboScope" />


## How does it work?

Example of how to utilize useFBO hook, render a scene to a texture and use it in a shader.
In this case, the webglrendertarget texture from useFBO hook is used in a scope where a
vignette and lens distortion effects are applied and a reticle is added.


This example demonstrates how to effectively use the useFBO hook for rendering a scene into a texture,
which is then used in a custom shader material that for a scope view,
featuring vignette and lens distortion effects.

### Scene setup

The scene is constructed using two free models sourced from Sketchfab:
a piece of terrain and a scope model. These models are converted into Svelte components using the
[Threlte gltf CLI tool](/docs/reference/gltf/getting-started) tool.

The scope model is attached directly to the PerspectiveCamera so that both move in sync with
the user's mouse movements. A circular mesh is positioned as a child of the scope and serves as an eyepiece -
this is where the custom ShaderMaterial is used for simulating the view through the scope.

Control over the scope—activating it, moving it, and enabling pointer lock—is managed within a Controls.svelte file.

### Rendering the scene to a texture

A  hook is utilized to prepare a renderTarget that we will render the
scope view texture to. The resolution is downscaled since the scope will only take a part of the screen and there
is no need to hafe a full resolution texture.

The rendering happens in the below `useTask` hook. Here's what happens:
	1. Scope visibility is turned off. We don't want it in the screen capture.
	2. Camera FOV is changed and projection matrix updated. This is how scope zoom happens. We're using FOV to "zoom in" and "out". If we
	simply moved camera forward and back, we could for example see behind the obstacles etc.
	3. Renderer target is set to the one made with the useFbo hook
	4. Scene is rendered
	5. Renderer target is set back to `null`, which means that from now on the scene will render to screen.
	Camera FOV is put back at the base value and scope is made visible.


The [useFBO](/docs/reference/extras/use-fbo) hook is used to prepare a render target for the scope's view texture.
Given that the scope's viewport occupies only a fraction of the full screen,
the texture's resolution is appropriately downscaled to conserve resources.

The rendering process happens in `useTask` hook.

```ts
useTask(() => {
    if (!scope || !$scoping) return
    const cam = $camera as PerspectiveCamera

    scope.visible = false
    cam.fov = $zoomedFov
    cam.updateProjectionMatrix()
    cam.matrixWorldNeedsUpdate = true
    renderer.setRenderTarget(renderTarget)
    renderer.render(scene, cam)

    renderer.setRenderTarget(null)
    cam.fov = baseFov
    cam.updateProjectionMatrix()
    scope.visible = true
  })
```

Here's what happens step by step:

1. The scope's visibility is set to `false` to prevent it from appearing in the texture capture.
2. The camera's field of view (`fov`) is adjusted, and its projection matrix is updated to apply current zoom level.
3. The renderer's target is switched to the one created by the useFBO hook.
4. The scene is rendered from the perspective of the adjusted camera.
5. The renderer's target is reset to `null` for rendering to the screen again, and the camera's FOV is restored to its
original setting, with the scope becoming visible again.

### Scope shader

The shader for the scope's view employs two textures: the rendered scene texture and a reticle image.

Inside the shader:
- **UV Adjustment**: To accommodate different screen sizes and the circular shape of the scope, UV coordinates are adjusted for proper mapping of the view texture onto the scope.
- **Cubic Lens Distortion**: The scene texture is distorted using a cubic lens effect to simulate the optical characteristics of a real scope.
- **Vignetting**: A vignette effect is applied to the distorted scene texture, darkening the edges around the scope.
- **Reticle Overlay**: The reticle texture is blended with the modified scene texture, adding the crosshair overlay to the scope's view.
